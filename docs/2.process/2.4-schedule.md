# 2.4 进程调度

在上一节的末尾，我们提到了 `kmt_schedule` 这一函数：

```c
Context *kmt_schedule(Event ev, Context *context);
```

本节详细描述其工作流程，并介绍各种调度算法的使用。

## 2.4.1 进程调度概述

进程调度的主要功能是：按照一定的策略选择—个处于**就绪状态**的进程，使其获得 cpu 并执行。

## 2.4.2 kmt_schedule 处理步骤

`kmt_schedule` 在调度前会回收已结束的进程空间；在末尾将会切换上下文并返回。其大致可以分为三个步骤：

1. 处理当前进程
2. 选择下一个进程
3. 执行上下文切换

当系统进行进程调度时，首先要确保持有当前 cpu 的自旋锁，否则在对进程队列操作时不能确保正确性。然后执行步骤一，如果当前 cpu 进程已经处于 `killed` 状态，则需要将其从进程队列中删除；其次执行步骤二，根据不同的进程调度算法（FCFS，SJF，RR，优先级等）选择可以被当前 cpu 执行的进程。最后执行步骤三，将下一个要执行的进程设置为 `Running` 状态，返回其上下文信息并将计数器 `count` 加一。

### 2.4.3 设计细节

1. 进程队列在 `kmt.c` 中由一个全局变量 `root_task` 为队列首构成。 `roo_task` 是一个特殊的进程，进程调度算法永远不会选择到它，它仅仅作为队列首供队列遍历使用。
2. 根据当前进程 `cur` 的 `cur->killed` 是否标记为 1 判断是否需要回收该进程。如果是，则释放其内存空间。
3. 在执行上下文切换时，变量 `ret` 用来存即将要执行的进程 `tp` 的上下文，并同时将 `tp` 的 `context` 置为空，这是为了保护其在离线时不受影响。如果进程队列为空，则此时需要返回 `null_contexts[cpu编号]` 内的 `context` 。

具体流程图如下

```flow
s=>start: kmt_schedule
s1=>operation: 释放可回收进程空间
s3_cond=>condition: 存在下一个可供调度的进程
s3_op1=>operation: 设置进程状态
s3_op2=>operation: 返回 null_contexts[cpu]
s3_op5=>operation: 将进程设置为当前任务
s3_op8=>operation: 设置当前任务为 NULL
e=>end: return ret
s->s1->s3_cond
s3_cond(yes)->s3_op1->s3_op5(right)->e
s3_cond(no)->s3_op2->s3_op8->e
```

### 2.4.4 调度算法

可供调度的进程需满足如下条件：

- 其 `owner` 为 -1 或 `current_cpu()`，即刚进入队列，还没有被任何一个 cpu 执行过，或已经被该 cpu 执行过；
- 其 `state` 为 Embryo 或 Waken up

满足以上条件的进程若被选出作为下一个运行的进程，则将其状态转为 `Running` 。

可供使用的各种调度算法有：

- FCFS: 按进入时间先后排成一队，每次选择队伍最前面的进程获得 CPU 并执行
- Priority: 每次调度时选择优先级最高的进程
- Round Robin: 每个进程轮流使用 CPU 资源，在时钟中断到来时进行时间片的重新分配。
- Multi Queue: 拥有多个进程队列，每个进程队列可以采用不同的调度策略。

目前，我们采用的是 FCFS 进行调度。后续将会陆续实现这些调度算法。
