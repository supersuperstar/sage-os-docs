# 3.2 虚拟文件系统 vfs
## 3.2.1 为何要存在VFS
VFS是操作系统的文件系统虚拟层，在其下是实体的文件系统。虚拟文件系统的主要功用，在于让上层的软件，能够用单一的方式，来跟底层不同的文件系统沟通。在操作系统与之下的各种文件系统之间，虚拟文件系统提供了标准的操作接口，让操作系统能够很快的支持新的文件系统。简单来说，虚拟文件系统为系统提供了一个统一的文件接口，使得上层应用无需关心不同文件系统的操作，而是通过**同一方式**访问不同的文件系统。
## 3.2.2 VFS要做些什么
在回答这个问题之前，我想先引用一句富有哲理的话：**_万丈高楼平地起_** 。我们现在已经知道VFS的目的是为不同的文件系统（或者可以说是设备）提供统一的接口。那么想要知道VFS要做些什么就要知道这些设备都做了什么。
### 3.2.2.1 底层设备
幸运的是，在我们所使用的环境中，与底层设备打交道已经被极大的简化，各个设备可以看成一个个可以随机存取的数组，这极大的简化了与底层设备打交道所需要的代码量。在这里我们简单介绍几个频繁打交道的设备。
#### 磁盘
我们所有的持久性数据，可以说都是存储在磁盘上。关于该文件系统的实现，已经在 _3.1.1_ 中做了详细阐述。此时如果一个进程想访问这个文件系统内的资源，就需要提供它要访问的路径。通过对路径的解析，VFS得知了该资源位于磁盘设备上，接下来要做的事就是调用磁盘文件系统的 ``read``，``write`` 等一系列接口即可。
#### 字符终端
字符终端是一个显示设备。它只提供简单的 ``read`` 和 ``write`` ，功能是从终端读取输入和显示输出。很显然字符终端不提供任何其他操作，如``open``,``close``等。那么相应的，在VFS实现时要屏蔽对该设备的这些操作。

### 3.2.2.2 VFS实现
通过对不同设备的简要了解，我们大致知道了VFS要做些什么：**判断操作进行在哪一个文件系统，将统一格式的操作转化为各个设备能接受的操作并屏蔽那些设备不支持的操作**。重要的一点是要知道操作在哪一个文件系统。进程提供路径，VFS来判断属于哪一文件系统，再执行对应操作。那么这里就涉及到了另一个关键点：**路径解析**。关于路径解析的部分,已经在 _3.1_ 节中所介绍。现在我们只需要知道，VFS帮我们获得了这一重要信息。那么接下来要做的事情就是 `` if else `` 了。

当然，为了避免大量的 ``if else `` ,环境贴心的提供了 ``MODULE`` 这一宏定义，使得可以像面向对象那样使用不同的文件系统“对象”来对其进行操作。这里的细节就不继续讨论了，只需要知道，文件系统被抽象成了拥有同一父类的对象即可。

### 3.2.2.3 VFS接口
```c

//提供调用该接口的进程，路径和打开方式，打开指定文件。打开成功返回进程文件描述符，否则返回-1
//值得注意的是，open一个已经打开的文件且flags包含O_CREAT（即创建新文件标志），会创建一个新的fd并指向该文件而不会新建一个同名文件。
int sys_open(task_t *proc, const char *pathname, int flags);

//给定进程和进程文件描述符，关闭指定文件，关闭成功返回0，不成功返回-1
int sys_close(task_t *proc, int fd);

//给定进程和进程文件描述符，从指定文件中读取nbyte字节数据到buf中，返回读取的字节长度
int sys_read(task_t *proc, int fd, void *buf, size_t nbyte);

//给定进程和进程文件描述符，写入buf中的nbyte字节数据到指定文件中，返回写入的字节长度
int sys_write(task_t *proc, int fd, void *buf, size_t nbyte);

//将两个路径建立链接，即两个路径指向同一文件
int sys_link(task_t *proc, const char *oldpath, const char *newpath);

//解除路径的链接
int sys_unlink(task_t *proc, const char *pathname);

//创建一个新的路径
int sys_mkdir(task_t *proc, const char *pathname);

//改变进程的路径
int sys_chdir(task_t *proc, const char *path);

//获取进程文件描述符fd指向文件的状态，获取成功返回0，否则返回-1
int sys_fstat(task_t *proc, int fd, stat_t *buf);

//使得进程文件描述符fd所指向的文件被深拷贝，使得两者状态完全相同且操作同步
int sys_dup(task_t *proc, int fd);
```


## 3.2.2 演示结果
在VFS演示程序中，我们创建了一个进程。**该进程的目录为根目录**。该进程所做工作如下：
- 在当前目录创建 ``usr`` 文件夹
- 在根目录下创建**两次** ``/usr/1`` 文件夹
- 进程调用 ``open`` 打开文件 ``/usr/1/te.c`` ,打开方式为创建和**可读写**
- 打印系统文件描述符表中的文件项
- 进程调用 ``open`` 再次打开文件 ``/usr/1/te.c`` ,打开方式为创建和**只写**
- 打印系统文件描述符表中的文件项
- 向**可读写**方式打开的 ``/usr/1/te.c`` 文件中写入 ``hello world!``
- 进程调用 ``open`` 再次打开文件 ``/usr/1/te.c`` ,打开方式为创建和**只读**
- 进程调用 ``lseek`` 重置**可读写**方式打开的文件的指针
- 读出**可读写**方式打开的文件的内容并打印
- 关闭三个已打开文件
- 重复执行一遍上述操作，但不用 ``lseek`` 而是读出**只读**方式打开的文件的内容并打印
- 测试其他设备读写

```c
#include <kernel.h>
#include <klib.h>
#include <user.h>
#include <am.h>
#include <logger.h>
#include <file.h>
#include <fs.h>

void func(void* arg) {
  task_t* task = (task_t*)arg;
  vfs->mkdir(task, "usr");
  vfs->mkdir(task, "/usr/1");
  vfs->mkdir(task, "/usr/1");

  int fd = vfs->open(task, "/usr/1/te.c", O_CREAT | O_RDWR);
  file_print_info(1);
  int fd3 = vfs->open(task, "/usr/1/te.c", O_CREAT | O_WRONLY);
  file_print_info(1);
  char buf[50];
  memset(buf, 0, sizeof(buf));
  int w   = vfs->write(task, 3, "hello world!", 13);
  int fd2 = vfs->open(task, "/usr/1/te.c", O_RDONLY);
  file_print_info(1);
  vfs->lseek(task, 3, 0);
  int r = vfs->read(task, 3, buf, 13);
  printf("%d %d %d %d %d\n", fd, fd3, w, fd2, r);
  printf("data is:%s\n", buf);
  vfs->close(task, 3);
  vfs->close(task, 4);
  vfs->close(task, 5);
  file_print_info(1);

  for(int i=0;i<10;i++){
    inode_print(i);
  }

  fd = vfs->open(task, "/usr/1/te.c", O_CREAT | O_RDWR);
  file_print_info(1);
  fd3 = vfs->open(task, "/usr/1/te.c", O_CREAT | O_WRONLY);
  file_print_info(1);
  memset(buf, 0, sizeof(buf));
  w   = vfs->write(task, 3, "hello world version 2!", 23);
  fd2 = vfs->open(task, "/usr/1/te.c", O_RDONLY);
  file_print_info(1);
  r = vfs->read(task, 4, buf, 23);
  printf("%d %d %d %d %d\n", fd, fd3, w, fd2, r);
  printf("data is:%s\n", buf);
  vfs->dup(task, 4);
  vfs->close(task, 3);
  vfs->close(task, 4);
  vfs->close(task, 5);
  file_print_info(1);

  fd=vfs->open(task,"/dev/random",O_CREAT);
  r=vfs->read(task,fd,0,0);
  printf("read from RANDOM is %d\n",r);
  r=vfs->mkdir(task,"/dev/input");
  printf("mkdri result is %d\n",r);

  while (1)
    ;
  // vfs->link(task,"","/uproc/task1");
}

int main() {
  _log_mask = LOG_ERROR | LOG_INFO | LOG_WARN;
  ioe_init();
  cte_init(os->trap);
  os->init();
  vme_init(pmm->pgalloc, pmm->free);
  uproc->init();
  vfs->init();

  task_t* task = pmm->alloc(sizeof(task_t));
  kmt->create(task, "test", func, task);

  mpe_init(os->run);
  return 1;
}
```

### 结果

![3-2-1](./assets/5.png)

