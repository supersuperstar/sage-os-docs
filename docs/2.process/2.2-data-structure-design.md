# 2.2 数据结构设计

## 2.2.1 task_t (pcb)

``task_t``在课本中的解释是进程控制块，但是在操作系统设计者的眼中，它是一个将我们视角中的进程和cpu视角中的进程联系起来的结构体（context和stack是机器视角的）。

在机器的视角，它们看到的只有进程的栈空间以及各种寄存器（也就是我们常说的上下文），试想一下，如果我没有task甚至说没有kmt，我只是在每一次中断时候随机设置我的esp和rip寄存器，我的机器也可以跑起来，如此可以说我们的操作系统是一个一根控制整个系统稳定运行的线。

而剩下的属性就是我们作为一个操作系统，或者说作为一个开发者的角度对进程应该看到的东西。

```c
enum task_states {
  ST_U,  // Unused
  ST_E,  // Embryo
  ST_T,  // To sleep
  ST_S,  // Sleeping
  ST_W,  // Waken up
  ST_R,  // Running
  ST_Z,  // Zombie
  ST_X   // Special
};
struct task {
  uint32_t pid;           //进程标志符
  const char* name;       //进程名称
  void (*entry)(void*);   //入口函数地址
  void* arg;              //函数参数
  enum task_states state; //进程状态
  sem_t* wait_sem;        //指向信号量
  bool killed;            //是否被kill
  uint32_t owner;         //所属cpu
  uint32_t count;         //计数器，防止死锁
	
  /*
   * 栈空间及前后保护
   */
  char fenceA[32];				
  char stack[8192];
  char fenceB[32];
  
  Context* context;        //上下文
	
  struct list_head list;
};
```
