# 1.1 物理内存管理

## 1.1.1 伙伴系统

### 概述

为了方便管理内存，避免产生大量的内存碎片，需要一个内存管理系统来维护内存分配的过程，但是过于详细内存分配管理系统也会占用过大的内存空间（如：每一个内存单元对应一个管理单元，则内存空间会浪费一半），伙伴系统和slab分配器结合的物理内存管理也随之产生。

### 设计思路

伙伴系统巧妙的将地址的二进制表示法和线段树的二分性进行了巧妙的结合，系统的基本数据结构是``struct chunk``，后面都会简称为``块``，它维护着$2^{order}$个页。当一个大小的内存请求到来时，首先计算满足条件的最小秩为多少，然后向伙伴系统申请相应秩的内存块。

伙伴系统中维护着一个分级队列，即对应着块的秩。首先系统会检查申请秩的队列，如果有空闲则直接分配；如果没有则进行向上查找，直到找到可用块，随后将其不断二分，直到分离到需要的秩。然后通过内存转换得到对应的其实物理地址。

当回收内存时，递归合并伙伴块，直到所对应伙伴块已经被分配或无伙伴块。

### 设计细节

1. 如何获取伙伴块？

   在考虑这个问题之前，我们需要对内存地址有一定的了解。

   我们有伙伴系统的前提是，分配的空间在地址逻辑上是连续的。这样我们才有了如下的内存地址格式。

   ```
       +---------------------------------+-------------------+
       |            base addr            |      offset       |
       +---------------------------------+-------------------+
       |                                                     |
       |<-----------------------64bits---------------------->|
       |                                                     |
   ```

   而对于``offset=0``的内存块来说，大小为4个内存单元时，下一个内存块就应该是``offset=4``而此时二进制表示法为``0x0100``。所以我们有一个假说，即我们获取对应块的内存地址的公式为${address}\oplus(1 << (order+log_2({pagesize})))$。因为二进制的特殊性，我们可以无进位加法和减法没有区别，都可以使用异或进行运算。

2. 如何获取块所对应的起始内存地址？

   我们假定单元内存块都分配着一个页，这样的话第n个内存块对应着第n个内存单元页，而无论对应块的order为多少，它所对应的起始内存地址都不会改变。由此可以易得，地址转换的公式为``(chunk - chunk_metadata) * SZ_PAGE + begin_addr``，反之亦然。

3. 堆区是如何分配的？

   如图所示：

   ```
         heap_end<---+--------------+
                     |   metadata   +--->pool&chunk(pages),etc.
       meta_start<---+--------------+      (for kernel)
                     |              |
                     |              |
                     |              |
                     |     free     |
                     |    spaces    |
                     |  (for user)  |
                     |              |
                     |              |
       heap_start<---+--------------+
   ```

   

## 1.1.2 SLAB 分配器
