# 0.3 测试与演示

## 0.3.1 测试框架介绍

如果只能通过单一的方式打包 kernel 镜像并进行调试，无疑会非常麻烦，因为这需要频繁修改入口代码。此外，操作系统是一个复杂的整体，开发操作系统需要确保每个子模块的正确性。

为了便于单独测试各个模块的正确性，我们设计了一个简易的测试框架，也就是 `test` 目录。

测试框架支持以下功能：

- 一键回归测试
- 编译/运行单个单元测试
- 调试单个单元测试（native 和 x86_64-qemu）
- 运行测试作为演示

### 目录结构说明

`test` 目录内容如下：

```
test
├── build       # 存放编译后的可执行文件
├── out         # 存放测试输出（stdout重定向）
├── include     # 存放头文件
└── units       # 存放单元测试的 .c 文件
```

## 0.3.2 使用测试框架开发测试或演示

### 编写单元测试

`units` 下可以有两种文件：

- `test_` 开头的 c 程序将被视作自动化测试，要求不能陷入死循环
- 其他程序将用于运行和展示，可以死循环

你可以参考 `test_add.c` 文件，使用数组对多种输入输出进行判断。

在编写时，如果你的测试比较庞大，建议使用 `logger` 而不是 `printf` 打印结果。

### 环境变量

你可以直接执行 `export` 定义环境变量，也可以在 make 命令中加入环境变量。建议使用前者，例如：

```shell
export smp=4
export LOG_MASK=15
```

可配置的环境变量有：

- `ARCH`: 当前支持 `native` 和 `x86_64-qemu`, 若 ARCH 不指定，则默认为 `x86_64-qemu`.
- `smp`: 处理器数量，默认为 2
- `CFLAGS_EXTRA`: gcc 编译时的额外选项，默认为空。例如 `"-DSIMULATE_PMM"` （已默认加上 `-DTEST` 和 `-DLOG_MASK=xxx`）
- `LOG_MASK`: logger 输出 mask, 详见 logger.h. 默认输出 error(8), warn(4), info(2), 也就是说默认值为 14. 如果你要输出 success(1)，设置为 15 即可

### 运行测试

**运行全部测试：**

```shell
make test
```

如果出现错误，可以查看 `out` 文件夹内的输出内容。

**运行单个测试：**

```shell
make run target=xxx
```

必须要指定 `target=xxx`，其中 `xxx` 是在 `units` 目录下的文件名（没有 .c 后缀）。

**调试单个测试：**

为了便于调试单个测试，编写了 vscode 的相应调试配置，你只需要把 `.vscode` 目录下的模板文件复制一份（注意不要删除或直接改名）并更名为 `launch.json` 和 `tasks.json` 即可使用。

如果你要调试 native，在对应单元测试文件上直接调试，配置选择 `unit test (native)` 即可。

如果你要调试 QEMU，运行如下命令：

```shell
make debug target=xxx
```

并在对应单元测试文件运行调试配置 `unit test (QEMU)` 即可。

**清除编译文件**

```shell
make clean
```

## 0.3.3 测试框架原理说明

下面以 `make test` 为例，说明当你运行回归测试时发生了什么事情：

1. GNU make 程序读取 `test/Makefile` 文件并执行 `run` target；
2. Make 将会扫描 `units` 下的每一个 .c 文件，并为它生成对应的 `Makefile.xxx`；
3. 接着，脚本将会自动运行 `make -f Makefile.xxx`，进行编译并运行（编译时会链接 AM 和 kernel）；
4. main() 函数将会被执行，程序的输出将重定向到 `out/xxx.out` 目录中，脚本将会检查运行是否成功：
   - 如果是 `native` 架构，直接检查返回值
   - 如果是 `x86-64_qemu` 架构，将会检查 `out/xxx.out` 中 CPU 的 halt 返回值
     如返回值为非 0, 则代表该项测试失败。
5. 打印出最终测试结果。

## 0.3.4 其它问题和注意事项

1. 如果更改代码后运行结果还是出错，请 `make clean`；若清除后仍出现错误的文件链接或使用了此前的编译文件，请删除项目内所有 build 目录（包括 am/klib/kernel 等目录下的 build 目录）并重试。

2. 运行在 `native` 架构时，将不会链接 `klib`，而是使用标准库函数。

3. 调试时若出现与 signal 有关的错误，请检查 launch.json 配置是否正常。如果用 gdb 命令行，需要执行 `handle SIGUSR1 SIGUSR2 SIGSEGV noprint nostop`.

4. 编译单元测试链接 `kernel` 时，将不会编译 `kernel/framework/main.c` 文件，这使得单元测试内的 main 函数可以被执行。

5. 如果不希望链接 `kernel`，可以添加 `NOKERNEL=true` 选项到命令中。

6. 编译单元测试时将会 define TEST 标志。如果需要在测试框架以外写测试逻辑，可以借助 `#ifdef TEST` 实现。`os_run` 函数使用了这个方法。
