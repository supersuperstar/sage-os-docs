# 4.1 klib
## 4.1.1 stdio.c
### 概述
  stdio为标准输入输出库，为系统和其他应用提供了一系列的标准输入输出函数。所有输入和输出都由抽象的字节流来完成。但是我们所完成的系统功能简单，并未实现标准输入输出的全部库函数和宏，因此只实现了printf家族的一些格式化输出函数。

### 接口说明
```c
//向标准输出流输出格式化字符串,返回输出字符个数
int printf(const char *fmt, ...);

//向指定输出流out输出格式化字符串,返回输出字符个数
int sprintf(char *out, const char *fmt, ...);

//向指定输出流out输出格式化字符串,输出长度最长为n,返回输出字符个数
int snprintf(char *out, size_t n, const char *fmt, ...);

//向指定输出流out输出格式化字符串,指定参数列表，返回输出字符个数
int vsprintf(char *out, const char *fmt, va_list ap); 

//向指定输出流out输出格式化字符串,输出长度最长为n,指定参数列表，返回输出字符个数
int vsnprintf(char *out, size_t n, const char *fmt, va_list ap);

```

### 设计思路
标准输出函数看似很多，但是只需要实现其中最泛用的一种，也就是``vsnprintf``，即可轻易实现其他输出函数。``vsnprintf``函数向指定输出流输出格式化字符串,输出长度有限制,指定参数列表并返回输出字符个数。例如，``vsprintf``函数只需将输出长度限制为``INT_MAX``,就可以看作是无限制并调用``vsnprintf``。而不定参数的``snprintf``只需要将不定参数转化为``va_list``即可调用``vsnprintf``。

### 设计细节
#### 1.如何设计变量识别格式字符串
格式字符串如下
>     FORMAT:
>     %[flags][width][.precision][length]specifier
具体细节如下
::: details flags
|字符|描述|
|----|----|
|space|使得输出前缀1个空格。|
|0|如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。|

:::
::: details width
width给出显示数值的最小宽度，典型用于制表输出时填充固定宽度的表目。实际输出字符的个数不足域宽，则根据右对齐进行填充。如果该描述符为*，则从参数列表取下一个参数作为width。
:::
::: details precision
Precision指明输出的最大长度，依赖于特定的格式化类型。对于%d、%i、%p、%x的整型数值，是指最小数字位数，不足的位要在左侧补0，如果超过也不截断。如果该描述符为*，则从参数列表取下一个参数作为Precision。
:::
::: details length
在此不做处理
:::
::: details specifier
支持%d、%i、%p、%x的整型数值，%c，%s的字符类型
:::
#### 2.参数如何识别
对于字符型参数和字符串型参数，只需要通过``stdarg.h``提供的``va_arg``方法将其转换为``char``和``char*``即可。对于数值类型，先将其转化为Int类型，再通过调用print_num方法将Int输出为字符串到专用的vbuf(virables buffer)。随后再进行填充操作。

### 流程图
#### vsnprintf主体流程
```flow
st=>start: 进入函数
op1=>operation: 变量初始化
cond1=>condition: 格式字符串结束
cond2=>condition: 未遇到%且未结束
op2=>operation: 直接输出到输出流
op3=>operation: 处理flags
op4=>operation: 处理width
op5=>operation: 处理precision
op6=>operation: 处理specifier
e=>end: 输出

st->op1->cond1(no)->cond2(no)->op3->op4->op5->op6->e
cond1(yes)->e
cond2(yes)->op2->cond2
```
