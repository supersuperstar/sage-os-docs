# 4.2 shell

## 4.2.1 shell.c

### 概述

在计算机科学中，Shell是指“为使用者提供操作界面”的软件（command interpreter，命令解析器）。它接收用户命令，然后调用相应的应用程序。sage-os的shell是命令行式的shell，负责管理用户与操作系统之间的交互：解释用户的输入，并且处理各种各样的操作系统的输出结果。

### 命令说明

```c
//shell主程序
void shell_task(task_t *proc);
//路径读取
bool get_dir(const char *arg, const char *pwd, char *dir);
//申请子进程
int fork1(task_t *proc);
//子进程执行shell命令
void runcmd(const task_t *proc,char *arg, const char *pwd, char *ret,int i)
//列出能用的命令
FUNC(man);
//打印命令
FUNC(echo);
//列出当前路径
FUNC(pwd);
//显示指定工作目录下之内容
FUNC(ls);
//切换当前工作目录
FUNC(cd);
//查看文件
FUNC(cat);
//写入文件
FUNC(write);
//建立一个新的连接
FUNC(link);
//创建目录
FUNC(mkdir);
//删除目录
FUNC(rmdir);
//删除指定文件
FUNC(rm);
//运行指定可执行文件
FUNC(run);
//列出正在运行的进程
FUNC(ps);
//列出内存信息状态
FUNC(mem);

```

### 设计思路

sage-os 的shell 基于linux的“万物皆文件”的思想，将用户输入和系统输出存储在``stdin``和``stdout``文件中。我们采用四个数组``buf`` 、``pwd``、 ``cmd``、 ``ret``

其中``buf``记录当前shell进程的stdin 和stdout地址，以及作部分临时变量使用  

``pwd``记录当前shell所在的工作目录  

``cmd``记录当前输入的全部指令  

``ret``作为子进程运行命令后所记录的返回值，通常用于写入``stdout`` 并输出  



命令执行结构上，我们参考多种现代操作系统方法，最终采取了主流的类linux和xv6的结合方法：  

当运行一个shell进程时，当用户输入命令并经过shell解析后，我们对于命令执行的策略是：

除``cd``命令必须由shell进程本身来实现之外，``fork``进程本身并由子程序执行，执行完毕后直接退出，而父进程（shell）则等待子进程执行完毕。

对于可执行文件（``run``命令），我们则采用``fork``后``execve``的常见操作系统做法来执行相应的程序。



### 设计细节

#### 1.解析命令

将命令存入``cmd``数组后，我们创建了一个指针``arg``来读取命令，为了简便的增改命令，在解析命令单词后，我们并没有采用case的方式，而是将所有用到命令存到数据结构中:

```c
const cmd_t cmd_list[] = {
  { "man",   man   },
  { "echo",   echo   },
  { "ls",     ls     },
  { "pwd",    pwd    },
  { "cd",     cd     },
  { "cat",    cat    },
  { "write",  write  },
  { "link",   link   },
  { "mkdir",  mkdir  },
  { "rmdir",  rmdir  },
  { "rm"   ,  rm     },
  { "run"  ,  run    },
  { "ps"   ,  ps     },
  { "mem"  ,  mem    },
};
```

当我们解析出命令后，遍历一般命令列表并找到相应的命令而去执行函数，这样方便了我们后期进行增改维护。



#### 2.解析路径

对于部分指令需要解析命令之后对用户输入的路径进行解析，我们采用

``bool get_dir(const char *arg, const char *pwd, char *dir)``

将``arg``和当前目录``pwd``结合解析后，传入到``dir``中供子函数使用，而当目录路径不存在时则返回``false``来告知调用函数。

### 流程图

#### shell主体流程

```flow
st=>start: 进入函数
op1=>operation: 初始化stdin stdout
op2=>operation: 读取用户输入
op3=>operation: 解析命令
cond1=>condition: 是否为 cd命令
op4=>operation: fork进入子程序执行命令，等待子程序执行完成
op5=>operation: 直接执行 cd 命令
op6=>operation: 子程序执行完成



st->op1->op2->op3->cond1(yes)->op5->op2
cond1(no)->op4->op6->op2
```
