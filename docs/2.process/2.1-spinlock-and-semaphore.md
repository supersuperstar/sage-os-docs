# 2.1 自旋锁和信号量
## 2.1.1 自旋锁
### 概述
自旋锁是专为防止多处理器并发冲突而引入，实现保护共享资源而提出一种锁机制，它在内核中大量应用于中断处理等部分。为了解决对某项资源的互斥使用，自旋锁在任何时刻最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。
### 自旋锁数据结构
```c
int efif[MAX_CPU] = {}; //cpu中断信息栈的起始信息
int ncli[MAX_CPU] = {}; //cpu中断信息栈的高度（计数器）
struct spinlock {
  bool lock_flag;    // 锁状态标记，当为真时表示已上锁
  const char *name;  // 锁名，用于输出日志
  int hold_cpuid;    // 当前使用锁的cpu，用于输出日志
};
```

### 接口说明
```c
//初始化一个自旋锁
void spin_init(spinlock_t *lk, const char *name);
//获得一个自旋锁
void spin_lock(spinlock_t *lk);
//释放一个自旋锁
void spin_unlock(spinlock_t *lk);
//返回当前cpu是否持有某个自旋锁
bool spin_holding(spinlock_t *lk);
//中断记录栈push功能
void spin_pushcli();
//中断记录栈pop功能
void spin_popcli();
```
### 设计思路
基于自旋锁的机制，我们可以设计一个最简单的自旋锁：
```c
void spin_lock(spinlock_t *lk)
{
	while (if(lk->lock_flag!=0)) {
    ;
  }
  lk->lock_flag = 1;
}
```
每次循环原子性的判断该锁是否被上锁：  
·如果没有则占用，跳出循环  
·如果被占用则继续循环（自旋）  
需要解锁时原子性的将该锁状态符置0即可 

看上去简单而美好，但这样的os运行效率偶尔会十分低下，原因也很简单：==中断==  
例如内核态切换、异常等原因，线程或程序经常会陷入中断状态，而如果占用某自旋锁的线程陷入中断状态，该自旋锁也会一直被该线程占用直到解除中断，从而导致其他希望占用该锁的线程在中断期间也一直自旋，嗷嗷待哺。  
因为自旋锁一般用于保护共享内存（或参数）的少量指令工作，如对某个公共值的加减（此功能指令只有一行），所以我们可以在cpu每次申请锁时关闭该cpu的中断，释放锁的时候再开中断。

```c
void spin_lock(spinlock_t *lk)
{
	interrupt colse()；
	while (if(lk->lock_flag!=0)) {
    ;
  }
  lk->lock_flag = 1;
}
```
这样处理似乎正确了，但其实还有问题，当我们需要修改两个以上共享参数时：
```c
lock(a);
lock(b);
······
unlock(b);  //open interrupt
unlock(a);
```
我们会在第一次unlock时就开中断而可能陷入中断，而使此优化失去意义，所以我们对每个cpu可以引入一个栈来存储放入了多少锁，通过push增加锁，pop弹出锁。  
此外，当我们申请锁的时候可能中断本来就被关闭了，而在最后一次弹出锁开中断则会导致原程序出现问题，所以我们选择用栈底存储cpu第一次增加锁时，关中断的原状态，在最后一次弹出锁时还原状态。
#### 申请锁的流程

#### 释放锁的流程

### 设计细节
::: warning 警告
建议创建锁时使用spin_init函数初始化
:::
::: warning 警告
不建议在``spin_lock(a)``和``spin_unlock(a)``之间放置太多指令，中断关闭时间过长会出现问题，例如输入中断关闭过长会导致部分输入被吞
:::
#### 申请锁
我们push中断信息栈后，使用``am``提供的库函数``atomic_xchg(int *addr, int newval) ``，该库函数会原子性地监测addr是否不为newval，并在不为newval的情况下改为newval，并返回修改结果从而退出while循环。
::: danger 危险
注意自旋锁不能多次嵌套使用，如：
``` 
lock(a);
······ //no unlock(a)
lock(a);
```
我们提供了spin_holding 和申请时的assert检查这种情况，请在编写时注意
:::
#### 释放锁
我们使用c++内联汇编函数``asm volatile（）``将锁状态置零后，pop中断信息栈。
#### 监测持有人
我们提供了spin_holding（）接口可让当前线程判断是否持有该锁，assert和内核常用该函数  
注意我们监测时需要关开中断，防止中断可能导致的问题
#### 中断信息栈
我们先建立一个中断栈示例，以1 0表示开中断 关中断：
```
    +---------------+
    |       0       |
    +---------------+
    |       0       |
    +---------------+
    |       0       |
    +---------------+
    |     1 / 0     | (栈底，记录最初的开关中断状态)
    +---------------+

```
观察发现我们其实并不需要一个栈，只需要一个计数器ncli去维护该cpu里含有多少锁（此计数器同时保证我们不需要按申请锁顺序释放锁）和一个efif去记录最初开关中断状态即可。  
所以我们最后使用一个计数器（ncli）组和efif组记录不同cpu的简化中断信息栈信息。  
使用qemu提供的库函数``iset()``开关中断

## 2.1.2 信号量
### 概述
信号量(Semaphore)，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。我们的信号量使用自旋锁作mutex，并添加了条件变量所需的等待功能和唤醒功能。
### 自旋锁数据结构
```
struct semaphore {
  spinlock_t lock;     // 该信号量的自旋锁（mutex）
  const char *name;    // 该信号量的名字
  volatile int value;  // 该信号量的值（条件/计数器）
};
```
### 接口说明
```c
// 信号量初始化，并初始化其自旋锁
void sem_init(sem_t *sem, const char *name, int value);
// 信号量wait操作，值非零时值减一，否则线程睡眠
void sem_wait(sem_t *sem);
// 信号量signal操作，值加一，并将该信号量下睡眠线程唤醒
void sem_signal(sem_t *sem);
```
### 设计思路
理解信号量原理，我们需要两个信号量函数即可应对大部分的并发模型：  
#### sem_wait：
sem_wait是一个函数，也需要是一个原子操作（所以应用了部分自旋锁），它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法：  
·如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。  
·如果对一个值为0的信号量调用sem_wait()，这个线程就会原地睡眠（sleep）直到有其它线程(例如生产者）增加了这个值（signal）使它不再是0为止（signal同时会唤醒该线程）。  
如果有两个线程都在sem_wait()中等待同一个信号量变成非零值。那么当它被第三个线程增加 一个“1”时，沉睡线程中只有一个能够对信号量做减法并继续执行，另一个还留在循环并再次进入沉睡状态。

#### sem_signal：
同sem_wait，该函数也需要大量原子操作，他的作用是将信号量的值加"1"。  
但因为节省资源需要，我们将等待该信号量值非零的线程全部沉睡，因此我们需要同时唤醒所有因为该信号量而沉睡的线程，竞争信号量的自旋锁，赢家得到使信号量的值减”1"的权利。

#### wait的流程

#### signal的流程

### 设计细节
#### wait
::: danger 危险
因为wait涉及到中断（yield)操作，所以这里提供了SOS的中断锁检查提醒，编程时请注意
:::
wait本身提供值减一的操作，但我们需要判断值非零才可进行操作。而因为会有多人消费一人生产的情况，当值为1时只有一个线程能抢到减一的权利，所以使用``while (sem->value <= 0)``的架构，以及对信号量本身的自旋锁的上锁，保证集体唤醒后只有信号量值大小的线程跳出循环，其他线程进入下一次循环进行沉睡。同时，进行沉睡的线程wait_sem会被标记为此信号量。  
我们使用``am``封装的``yield（）``使当前正在运行的线程进入沉睡。

#### signal
我们将值增加的同时，需要唤醒那些因当前信号量值为零而被沉睡的线程（消费者）。  
因为线程池采用链表形式，所以遍历一遍链表筛选wait_sem为当前信号量的线程，并将睡眠的唤醒
```c
if (tp->state == ST_S) tp->state = ST_W;
```