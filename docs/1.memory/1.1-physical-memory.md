# 1.1 物理内存管理

## 1.1.0 对外api说明

完成物理内存的分配与释放。

```c
void* kalloc(size_t size);
void kfree(void* ptr);
```

## 1.1.1 伙伴系统

### 概述

为了方便管理内存，避免产生大量的内存碎片，需要一个内存管理系统来维护内存分配的过程，但是过于详细内存分配管理系统也会占用过大的内存空间（如：每一个内存单元对应一个管理单元，则内存空间会浪费一半），伙伴系统和slab分配器结合的物理内存管理也随之产生。

### 接口说明

```c
//内存块到起始地址转换
void* chunk2virt(struct pmm_pool* mm_pool, struct chunk* chunk);

//起始地址到内存块转换
struct chunk* virt2chunk(struct pmm_pool* mm_pool, void* virt);

//合并伙伴块
struct chunk* chunk_merge(struct pmm_pool* mm_pool, struct chunk* chunk);

//将内存块分解至指定秩
struct chunk* chunk_split(struct pmm_pool* mm_pool, uint8_t order,
                          struct chunk* chunk);

//向空闲队列中添加块
void chunk_append(struct pmm_pool* mm_pool, struct chunk* chunk);

//从空闲队列中删除块
void chunk_del(struct pmm_pool* mm_pool, struct chunk* chunk);

//分配内存块
struct chunk* chunk_alloc(struct pmm_pool* mm_pool, uint8_t order);

//释放内存块
void chunk_free(struct pmm_pool* mm_pool, struct chunk* chunk);

//初始化伙伴系统
void buddy_init(struct pmm_pool* mm_pool, struct chunk* start_chunk,
                void* start_addr, uint64_t page_num);

//获取伙伴块
struct chunk* get_buddy_chunk(struct pmm_pool* mm_pool, struct chunk* chunk);
```

### 设计思路

伙伴系统巧妙的将地址的二进制表示法和线段树的二分性进行了巧妙的结合，系统的基本数据结构是``struct chunk``，后面都会简称为``块``，它维护着$2^{order}$个页。当一个大小的内存请求到来时，首先计算满足条件的最小秩为多少，然后向伙伴系统申请相应秩的内存块。

伙伴系统中维护着一个分级队列，即对应着块的秩。首先系统会检查申请秩的队列，如果有空闲则直接分配；如果没有则进行向上查找，直到找到可用块，随后将其不断二分，直到分离到需要的秩。然后通过内存转换得到对应的其实物理地址。

当回收内存时，递归合并伙伴块，直到所对应伙伴块已经被分配或无伙伴块。

### 设计细节

#### 堆区的分配

如图所示：

```
      heap_end<---+--------------+
                  |   metadata   +--->pool&chunk(pages),etc.
    meta_start<---+--------------+      (for kernel)
                  |              |
                  |              |
                  |              |
                  |     free     |
                  |    spaces    |
                  |  (for user)  |
                  |              |
                  |              |
    heap_start<---+--------------+
```

#### 内存池设计

为了方便管理元数据，我们设计了内存池。结构如下：

```c
struct pmm_pool {
  uint64_t begin_addr;
  uint64_t page_num;
  uint64_t size;
  struct chunk* chunk_metadata;
  struct free_list free_lists[BUDDY_MAX_ORDER];
};
```

其中包括了堆区地址``begin_addr``，页数，总大小，块元数据起始地址``chunk_metadata``，以及空闲链表（链表设计见[``list.h``设计说明](../4.apps/4.3-list.md)）。

#### 元数据初始化

1. 页面数量

   遵循着我们对堆区分配的设计，一个页对应着一块元数据，在已知堆区的起始地址和终止地址后，我们可以如下计算出页面数量。

   ```c
   nr_page =
         (uint64_t)(heap.end - heap.start) / (SZ_PAGE + sizeof(struct chunk));
   ```

2. 起始地址

   堆区起始地址只需要调用``abstract machine``的接口``Area heap``即可，而元数据起始地址的计算就是堆区起始地址偏移``SZ_PAGE * nr_page``即可。

   ```c
   pg_start = heap.start;
   pi_start = (bool*)(pg_start + nr_page * SZ_PAGE);
   ```

3. 空闲块初始化

   现在在内存池中已经有了``nr_page``个秩为0的内存块，现在对这些内存块遍历：如果该内存块的伙伴块在空闲队列中，则重复进行合并操作，并将最后的内存块加入空闲队列；如果不在空闲队列中，则直接加入空闲队列。

#### 获取伙伴块

在考虑这个问题之前，我们需要对内存地址有一定的了解。

我们有伙伴系统的前提是，分配的空间在地址逻辑上是连续的。这样我们才有了如下的内存地址格式。

```
    +---------------------------------+-------------------+
    |            base addr            |      offset       |
    +---------------------------------+-------------------+
    |                                                     |
    |<-----------------------64bits---------------------->|
    |                                                     |
```

而对于``offset=0``的内存块来说，大小为4个内存单元时，下一个内存块就应该是``offset=4``而此时二进制表示法为``0x0100``。所以我们有一个假说，即我们获取对应块的内存地址的公式为${address}\oplus(1 << (order+log_2({pagesize})))$。因为二进制的特殊性，我们可以无进位加法和减法没有区别，都可以使用异或进行运算。

#### 块地址与起始内存地址转换算法

我们假定单元内存块都分配着一个页，这样的话第n个内存块对应着第n个内存单元页，而无论对应块的order为多少，它所对应的起始内存地址都不会改变。由此可以易得，地址转换的公式为``(chunk - chunk_metadata) * SZ_PAGE + begin_addr``，反之亦然。



## 1.1.2 SLAB 分配器
