# 2.4 进程调度
## 概述
进程调度的主要功能是按照一定的策略选择—个处于**就绪状态**的进程，使其获得cpu并执行。
## 接口说明
```c
/**
 * @brief handler: schedule next task to run
 *        Notice: this should be the only handler which returns real Context
 *
 * @param ev
 * @param context
 * @return Context*
 */
Context *kmt_schedule(Event ev, Context *context);
```
## 设计思路
进程调度函数大致可以分为三个步骤：

  **Step1.** 处理当前进程
  
  **Step2.** 选择下一个进程
  
  **Step3.** 执行上下文切换
  
当系统进行进程调度时，首先要确保持有当前cpu的自旋锁，否则在对进程队列操作时不能确保正确性。然后执行**Step1**,如果当前cpu进程已经处于``killed``状态，则需要将其从进程队列中删除；其次执行**Step2**,根据不同的进程调度算法（FCFS，SJF，RR，优先级等）选择可以被当前cpu执行的进程。最后执行**Step3**,将下一个要执行的进程设置为``Running``状态，返回其上下文信息并将计数器``count``加一。
## 设计细节
### 整体流程
1. 进程队列在``kmt.c``中由一个全局变量``root_task``为队列首构成。``roo_task``是一个特殊的进程，进程调度算法永远不会选择到它,它仅仅作为队列首供队列遍历使用。
2. **Step1**中当前进程``cur``有一个单独的变量为``killed``,判断``cur %% cur->killed``即可知道当前进程是否存在并且是否已经被杀死。然后遍历进程队列找到``cur``并使用``pmm模块``中的``free``方法将其内存空间释放。
3. 在执行上下文切换时，变量``ret``用来存即将要执行的进程``tp``的``Context``,保存以后要将``tp``的``context``置为空。如果进程队列为空，则此时需要返回``null_contexts[cpu编号]``内的``context``。

具体流程图如下
```flow
s=>start: Schedule
s1_cond=>condition: Step1:cur && cur->killed
s1_op1=>operation: for each in root_task,find and free cur
s2_op1=>operation: Step2:foreach in root_task,schedule 
s3_cond=>condition: Step3:next process not NULL
s3_op1=>operation: state<=Running
s3_op2=>operation: ret<=next process context
s3_op3=>operation: next process context<=NULL
s3_op4=>operation: next process count+1 and %1024
s3_op5=>operation: set current task to next process
s3_op6=>operation: ret<=null_contexts[cpu]
s3_op7=>operation: null_contexts[cpu]<=NULL
s3_op8=>operation: set current task to NULL
e=>end: return ret
s->s1_cond
s1_cond(yes)->s1_op1->s2_op1
s1_cond(no)->s2_op1
s2_op1->s3_cond
s3_cond(yes)->s3_op1->s3_op2->s3_op3->s3_op4->s3_op5->e
s3_cond(no)->s3_op6->s3_op7->s3_op8->e
```

### 调度算法
在调度前，需要三个变量如下
```c
Context *ret = NULL;    //用来保存下一个要执行的进程的上下文
task_t *tp   = NULL;    //用来遍历进程队列，同时代表最终选择的进程
task_t *next = NULL;    //待选择的下一个进程
```
首先遍历进程队列，对于当前进程``tp``,需要先判断:
  **1.**如果其``owner``为``-1``（代表进程刚进入队列，还没有被任何一个cpu执行过）或者为当前cpu（代表该进程已经被该cpu执行过）。
  **2.**如果其``state``为``ST_E``（Embryo）或``ST_W``（Waken up）,满足这个条件表进程``tp``的状态可以转为``Running``。
在经过这两次判断后，代表当前进程``tp``有作为待切换进程的潜质。再调用不同算法。
#### FCFS
所谓 FCFS 就是先来先服务,每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，就会选择队伍最前面的进程，获得 CPU 并执行。
#### Priority
每个进程有优先级，每次调度时选择优先级最高的进程。
#### RR
每个进程轮流使用 CPU 资源，在其开始运行时，打开定时器，如果定时器到时间（或者执行阻塞操作），将被迫切换至下一个进程。每次进入schedule后，将当前执行的进程放入队列尾部，然后选择队列头部的程序进行调度。
#### MQ
拥有多个进程队列，每个进程队列可以采用不同的调度策略。**（暂未实现）**

代码实现如下
```c
  // pick the next task to run
  Context *ret = NULL;
  task_t *tp   = NULL;
  task_t *next = NULL;

  for (tp = root_task.next; tp; tp = tp->next) {
    // CHECK_FENCE(tp);
    if (tp->owner != -1 && tp->owner != cpu_current()) continue;
    if (tp->state == ST_E || tp->state == ST_W) {
      if (policy == FCFS || policy == RR) {//FCFS与RR算法都只需要取队列头部
        next = tp;
        break;
      } else if (policy == Priority && tp->priority > next->priority) {//优先级算法选择优先级最高的进程
        next = tp;
      }
    }
  }
  tp = next;
```

<!-- 调度算法流程图如下
```flow
s=>start: define variable
op1=>operation: tp<=root_task
cond1=>condition: tp not NULL
cond2=>condition: legal owner
cond3=>condition: legal state
op2=>operation: switch schedule policy
cond4=>condition: FCFS
cond5=>condition: Priority
cond6=>condition: RR
cond7=>condition: MQ
cond4_op1=>operation: next<=tp
cond5_cond=>condition: lexicographic
cond5_cond_op=>operation: next<=tp
cond6_cond=>condition: count
cond6_cond_op=>operation: next<=tp
cond7_op=>operation: no implement
op3=>condition: tp<=next process in list
e=>end: tp<=next
s->op1->cond1
cond1(no)->e
cond1(yes)->cond2
cond2(no)->op3
cond2(yes)->cond3
cond3(no)->op3
cond3(yes)->cond4
cond4(yes)->cond4_op1
cond4(no)->cond5
cond5(yes)->cond5_cond
cond5_cond(yes)->cond5_cond_op->op3
cond5_cond(no)->op3
cond5(no)->cond6
cond6(yes)->cond6_cond
cond6_cond(yes)->cond6_cond_op->op3
cond6_cond(no)->op3
cond6(no)->cond7
cond5(no)->cond6
cond7(yes)->cond7_op->op3
cond7(no)->cond4_op1
op3->cond1
cond4_op1->e
```

```flow
s=>start: define variable
op1=>operation: tp<=root_task
cond1=>condition: tp not NULL
cond2=>condition: legal owner
cond3=>condition: legal state
op2=>operation: switch schedule policy
cond4=>condition: FCFS
cond5=>condition: Priority
cond6=>condition: RR
cond7=>condition: MQ
cond4_op1=>operation: next<=tp
cond5_cond=>condition: lexicographic
cond5_cond_op=>operation: next<=tp
cond6_cond=>condition: count
cond6_cond_op=>operation: next<=tp
cond7_op=>operation: no implement
op3=>condition: tp<=next process in list
e=>end: tp<=next
s->op1->cond1
cond1(no)->e
cond1(yes)->cond2
cond2(no)->op3
cond2(yes)->cond3
cond3(no)->op3
cond3(yes)->cond4
cond4(no)->cond4_op1
cond4(yes)->cond5
cond5(no)->cond5_cond
cond5_cond(yes)->cond5_cond_op->op3
cond5_cond(no)->op3
cond5(yes)->cond6
cond6(no)->cond6_cond
cond6_cond(yes)->cond6_cond_op->op3
cond6_cond(no)->op3
cond6(yes)->cond7
cond5(no)->cond6
cond7(no)->cond7_op->op3
cond7(yes)->cond1
op3->cond1
cond4_op1->e
``` -->