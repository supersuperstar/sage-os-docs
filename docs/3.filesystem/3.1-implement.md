# 3.1 文件系统实现
## 3.1.1 磁盘读写接口
相比于真正的磁盘，AM提供了一个抽象的磁盘接口，使得可以通过调用底层接口 ``dev->read()`` 和 ``dev->write()`` 对磁盘进行随机读写。但是磁盘结构仍是由自己定义。因此我们在可随机读写的基础上，定义了属于自己的磁盘结构以及各种数据结构及其读写方法。在这一小节将会先介绍我们所定义的磁盘结构，再介绍存储在磁盘上的数据结构和他们的一些读写方法。
### 3.1.1.1 磁盘结构
![p3-1](./assets/1.png)
磁盘结构如上图所示，前 1MB 的空间留给 ``boot`` ,从 ``boot`` 往后第一个块存放 ``superblock_t`` ，第二个块开始存放 ``dinode_t`` 节点, ``dinode_t`` 节点结束后的下一个块开始存放 ``bit map`` ,接下来的块开始存放一系列的数据块 ``block`` .

### 3.1.1.2 磁盘上存储的数据结构
#### superblock
```c
typedef struct superblock {
  uint32_t size;        // Size of file system image (blocks)
  uint32_t nblocks;     // Number of data blocks
  uint32_t ninodes;     // Number of inodes.
  uint32_t inodestart;  // Block number of first inode block
  uint32_t bmapstart;   // Block number of first free map block
} superblock_t;
```
``size`` 代表整个虚拟磁盘的大小。
``nblocks`` 代表数据块的个数。
``ninodes`` 代表 dinode 节点个数，值得一提的是，考虑到磁盘上最多只有 nblocks 个数据块，因此 dinode 节点数量与其设置成相同大小。
``inodestart`` 代表第一个inode节点开始的块号。
``bmapstart`` 代表第一个位图开始的块号。
#### dinode
```c
#define DINODE_TYPE_N 0                           // unused
#define DINODE_TYPE_F 1                           // file
#define DINODE_TYPE_D 2                           // directory
#define NDIRECT       12                          // num of direct address
#define NINDIRECT     (BSIZE / sizeof(uint32_t))  // 128

typedef struct dinode {
  short type;                   // File type
  short nlink;                  // Number of links to inode in file system
  uint32_t size;                // Size of file (bytes)
  uint32_t addrs[NDIRECT + 1];  // Data block addresses
} dinode_t;
```
``dinode_t`` 是存储在磁盘上的 inode 节点，其中包含了节点类型 ``type`` ,其可选参数在 define 定义中给出。 ``nlink`` 表明XXXXXXXXXXX； ``size`` 表明了该节点对应的数据大小， ``addrs`` 则用于存储节点对应的块的块号。数组大小 +1 是因为最后一项存放间接地址块号。
### 3.1.1.3 内存中存储的数据结构
#### block
```c
#define NBLOCK        1024  // data block num
#define BSIZE         512   // block size

typedef struct block {
  uint32_t blk_no;
  uint8_t data[BSIZE];
} block_t;
```
``block_t`` 数据结构是块的一个缓冲，用于存放要读出的块的内容。
#### dirent
```c
#define PATH_LENGTH   32                          // path max length

typedef struct dirent {
  uint16_t inum;
  char name[PATH_LENGTH];
} dirent_t;
```
``dirent_t`` 存放目录名以及它对应的inode编号。
#### inode
```c
typedef struct inode {
  device_t* dev;    // Device
  uint32_t inum;    // Inode number
  int ref;          // Reference count
  spinlock_t lock;  // protects everything below here
  // delete valid because all inodes will be in memory at boot
  // int valid;

  short type;                   // File type
  short nlink;                  // Number of links to inode in file system
  uint32_t size;                // Size of file (bytes)
  uint32_t addrs[NDIRECT + 1];  // Data block addresses
} inode_t;
```
``inode_t`` 是存放在内存中的 inode 节点。从磁盘读取节点后，要对其附加一些信息，并存放在内存中的 inode 缓冲区内。其中 
``dev`` 表示节点的设备，因为只有一个虚拟磁盘，所以只有一种选择。
``inum`` 表示节点编号，与其在磁盘中的位置顺序相同。
``ref`` 表示XXXXXXXXXXXXXXXXXXXXX。
``lock`` 用于锁住对于其下方数据的操作，下方的数据与 ``dinode_t`` 相同。
### 3.1.1.4 其他定义
```c
//------------------一些用于计算地址偏移量的定义------------------------------------------
#define ROUNDUP_BLK_NUM(i) \
  (((i + BSIZE - 1) / BSIZE) * \
   BSIZE)  // 偏移量i对块大小向上取整，例如地址648对块大小512向上取整是1024

#define OFFSET_BOOT     (1024*1024)   //boot区域的偏移量，1MB
#define OFFSET_SB       512 //superblock偏移量，占一个块
#define OFFSET_INODE(i) (OFFSET_BOOT + OFFSET_SB + (sizeof(dinode_t) * i))//inode节点i偏移量
#define OFFSET_ALLINODE \
  (OFFSET_BOOT + OFFSET_SB + ROUNDUP_BLK_NUM((sizeof(dinode_t) * NBLOCK)))//最后一个inode节点结束的偏移量
#define OFFSET_BITMAP(i) (OFFSET_ALLINODE + (i / 8))                    //位图i地址偏移量
#define OFFSET_ALLBITMAP (OFFSET_ALLINODE + NBLOCK / 8)                 //最后一个位图结束的偏移量
#define OFFSET_BLOCK(i)  (ROUNDUP_BLK_NUM(OFFSET_ALLBITMAP) + i * BSIZE)//数据块的偏移量
```
### 3.1.1.5 文件系统接口函数

这里的文件系统接口函数是指对磁盘上的数据块和数据结构进行读写，并不涉及inode节点内的文件内容写入。未提及部分会在inode接口中做详细解释。
```c
//初始化，主要设置superblock的各项参数并且写入磁盘
void fs_init();

//向设备dev写入superblock
void fs_createsb(device_t* dev, superblock_t* sb);

//从设备dev读取superblock
void fs_readsb(device_t* dev, superblock_t* sb);

//从设备dev中按照数据块号blk_no读取块，存放在buf中。其中偏移量根据前面所定义的OFFSET_BLOCK(blk_no)获得
void fs_readblk(device_t* dev, uint32_t blk_no, block_t* buf);

//从设备dev中按照数据块号blk_no写入块，内容为buf中的data。其中偏移量根据前面所定义的OFFSET_BLOCK(blk_no)获得
void fs_writeblk(device_t* dev, uint32_t blk_no, block_t* buf);

//清空一个数据块，将数据置零。要注意的是，该函数并不会释放清零的块。
void fs_zeroblk(device_t* dev, uint32_t blk_no);

//分配一个空的数据块（其位图为0），返回分配的块号
uint32_t fs_allocblk(device_t* dev);

//释放编号为blk_no的数据块。要注意的是，释放并不会清空块内数据。只是将其在位图中的bit置零。
void fs_freeblk(device_t* dev, uint32_t blk_no);

//读取编号为inode_no（从0开始）的inode并放在参数inode中包含dinode数据的部分，并构造其它部分。
void fs_readinode(device_t* dev, uint32_t inode_no, inode_t* inode);

//将inode中的dinode信息写入磁盘。
void fs_writeinode(device_t* dev, uint32_t inode_no, inode_t* inode); 
```
## 3.1.2 文件描述符与文件接口
文件描述符是用来管理
### 3.1.2.1 数据结构定义
### 3.1.2.2 接口函数
## 3.1.3 inode接口