# 2.4 进程调度
## 概述
进程调度的主要功能是按照一定的策略选择—个处于**就绪状态**的进程，使其获得cpu并执行。
## 接口说明
```c
/**
 * @brief handler: schedule next task to run
 *        Notice: this should be the only handler which returns real Context
 *
 * @param ev
 * @param context
 * @return Context*
 */
Context *kmt_schedule(Event ev, Context *context);
```
## 设计思路
进程调度函数大致可以分为三个步骤：

  **Step1.** 处理当前进程
  
  **Step2.** 选择下一个进程
  
  **Step3.** 执行上下文切换
  
当系统进行进程调度时，首先要确保持有当前cpu的自旋锁，否则在对进程队列操作时不能确保正确性。然后执行**Step1**,如果当前cpu进程已经处于``killed``状态，则需要将其从进程队列中删除；其次执行**Step2**,根据不同的进程调度算法（FCFS，SJF，RR，优先级等）选择可以被当前cpu执行的进程。最后执行**Step3**,将下一个要执行的进程设置为``Running``状态，返回其上下文信息并将计数器``count``加一。
## 设计细节
1. 进程队列在``kmt.c``中由一个全局变量``root_task``为队列首构成。``roo_task``是一个特殊的进程，进程调度算法永远不会选择到它,它仅仅作为队列首供队列遍历使用。
2. **Step1**中当前进程``cur``有一个单独的变量为``killed``,判断``cur %% cur->killed``即可知道当前进程是否存在并且是否已经被杀死。然后遍历进程队列找到``cur``并使用``pmm模块``中的``free``方法将其内存空间释放。
3. 在执行上下文切换时，变量``ret``用来存即将要执行的进程``tp``的``Context``,保存以后要将``tp``的``context``置为空。如果进程队列为空，则此时需要返回``null_contexts[cpu编号]``内的``context``。

具体流程图如下
```flow
s=>start: Schedule
s1_cond=>condition: Step1:cur && cur->killed
s1_op1=>operation: for each in root_task,find and free cur
s2_op1=>operation: Step2:foreach in root_task,schedule 
s3_cond=>condition: Step3:next process not NULL
s3_op1=>operation: state<=Running
s3_op2=>operation: ret<=next process context
s3_op3=>operation: next process context<=NULL
s3_op4=>operation: next process count+1 and %1024
s3_op5=>operation:set current task to next process
s3_op6=>operation: ret<=null_contexts[cpu]
s3_op7=>operation: null_contexts[cpu]<=NULL
s3_op8=>operation:set current task to NULL
e=>end: return ret
s->s1_cond
s1_cond(yes)->s1_op1->s2_op1
s1_cond(no)->s2_op1
s2_op1->s3_cond
s3_cond(yes)->s3_op1->s3_op2->s3_op3->s3_op4->s3_op5->e
s3_cond(no)->s3_op6->s3_op7->s3_op8->e
```
